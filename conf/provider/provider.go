/*
 * Copyright 2024 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package provider

import (
	"os"
	"strings"

	"github.com/go-spring/spring-core/conf/reader"
	"github.com/go-spring/stdlib/errutil"
	"github.com/go-spring/stdlib/flatten"
)

var providers = map[string]Provider{}

func init() {
	Register("file", LoadFile)
}

// Provider defines a function type that provides configuration data from a specific source.
//
// If access to a remote server is needed, the information required to access it is usually
// placed in the source string or passed through environment variables.
//
// To support dynamic refresh, a version number field can be added and a regular Bean
// can be registered to listen for changes. When the version changes, the configuration
// can be updated.
type Provider func(optional bool, source string) (*flatten.Storage, error)

// Register registers a Provider for a specific configuration source type.
func Register(name string, p Provider) {
	providers[name] = p
}

// Load loads a configuration source and returns its content as a flattened Storage.
func Load(source string) (*flatten.Storage, error) {
	// For example, a spring.config.import value of optional:file:./myconfig.properties
	// allows your application to start, even if the myconfig.properties file is missing.

	var (
		provider string
		optional bool
	)

	// Parse the source string with up to 3 parts: optional, provider type, and path
	if ss := strings.SplitN(source, ":", 3); len(ss) == 3 {
		optional = ss[0] == "optional"
		provider = ss[1]
		source = ss[2]
	} else if len(ss) == 2 {
		provider = ss[0]
		source = ss[1]
	} else if len(ss) == 1 {
		provider = "file"
		source = ss[0]
	} else {
		err := errutil.Explain(nil, "invalid config source %s", source)
		return nil, errutil.Explain(err, "read config %s error", source)
	}

	p, ok := providers[provider]
	if !ok {
		err := errutil.Explain(nil, "unsupported provider type %s", provider)
		return nil, errutil.Explain(err, "read config %s error", source)
	}
	return p(optional, source)
}

// LoadFile loads a configuration file and returns its content as a flattened Storage.
// If the file does not exist and optional is true, it returns nil without error.
func LoadFile(optional bool, source string) (*flatten.Storage, error) {
	m, err := reader.ReadFile(source)
	if err != nil {
		if os.IsNotExist(err) && optional {
			return nil, nil
		}
		return nil, err
	}
	s := flatten.NewStorage()
	fileID := s.AddFile(source)
	for k, v := range flatten.Flatten(m) {
		if err = s.Set(k, v, fileID); err != nil {
			return nil, err
		}
	}
	return s, nil
}
